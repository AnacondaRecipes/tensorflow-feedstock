From 93a9dbdb7387d23522bdc6d22a399ae4d808c8ad Mon Sep 17 00:00:00 2001
From: Eric Lundby <Eric.Lundby@gmail.com>
Date: Mon, 15 Sep 2025 14:22:06 -0600
Subject: [PATCH 4/6] icu-unicode-changes

---
 tensorflow/core/kernels/string_lower_op.cc   | 55 ++++++++++++-
 tensorflow/core/kernels/string_upper_op.cc   | 55 ++++++++++++-
 tensorflow/core/kernels/unicode_ops.cc       | 82 +++++++++++++-------
 tensorflow/core/kernels/unicode_script_op.cc | 10 +--
 4 files changed, 163 insertions(+), 39 deletions(-)

diff --git a/tensorflow/core/kernels/string_lower_op.cc b/tensorflow/core/kernels/string_lower_op.cc
index 51c61450..6e7aa937 100644
--- a/tensorflow/core/kernels/string_lower_op.cc
+++ b/tensorflow/core/kernels/string_lower_op.cc
@@ -18,7 +18,9 @@ limitations under the License.
 #include <string>
 
 #include "absl/strings/ascii.h"
-#include "unicode/unistr.h"  // from @icu
+#include "unicode/ucnv.h"   // from @icu
+#include "unicode/ustring.h" // from @icu
+#include "unicode/utypes.h"  // from @icu
 #include "tensorflow/core/framework/kernel_def_builder.h"
 #include "tensorflow/core/framework/op_kernel.h"
 #include "tensorflow/core/framework/tensor.h"
@@ -56,9 +58,54 @@ class StringLowerOp : public OpKernel {
     } else {
       // The validation of utf-8 has already been done in GetAttr above.
       for (int64_t i = 0; i < input.size(); ++i) {
-        icu::UnicodeString us(input(i).c_str(), "UTF-8");
-        us.toLower();
-        us.toUTF8String(output(i));
+        const std::string& input_str = input(i);
+        
+        // Convert UTF-8 to UTF-16
+        UErrorCode status = U_ZERO_ERROR;
+        int32_t utf16_len = 0;
+        u_strFromUTF8(nullptr, 0, &utf16_len, input_str.c_str(), input_str.length(), &status);
+        
+        if (status == U_BUFFER_OVERFLOW_ERROR) {
+          status = U_ZERO_ERROR;
+          std::vector<UChar> utf16_buf(utf16_len);
+          u_strFromUTF8(utf16_buf.data(), utf16_len, nullptr, input_str.c_str(), input_str.length(), &status);
+          
+          if (U_SUCCESS(status)) {
+            // Apply lowercase conversion
+            std::vector<UChar> lower_buf(utf16_len * 2);  // Allow for expansion
+            int32_t lower_len = u_strToLower(lower_buf.data(), lower_buf.size(), 
+                                           utf16_buf.data(), utf16_len, 
+                                           nullptr, &status);
+            
+            if (U_SUCCESS(status) || status == U_BUFFER_OVERFLOW_ERROR) {
+              if (status == U_BUFFER_OVERFLOW_ERROR) {
+                status = U_ZERO_ERROR;
+                lower_buf.resize(lower_len);
+                lower_len = u_strToLower(lower_buf.data(), lower_buf.size(),
+                                       utf16_buf.data(), utf16_len,
+                                       nullptr, &status);
+              }
+              
+              if (U_SUCCESS(status)) {
+                // Convert back to UTF-8
+                int32_t utf8_len = 0;
+                u_strToUTF8(nullptr, 0, &utf8_len, lower_buf.data(), lower_len, &status);
+                
+                if (status == U_BUFFER_OVERFLOW_ERROR) {
+                  status = U_ZERO_ERROR;
+                  output(i).resize(utf8_len);
+                  u_strToUTF8(const_cast<char*>(output(i).data()), utf8_len, nullptr,
+                             lower_buf.data(), lower_len, &status);
+                }
+              }
+            }
+          }
+        }
+        
+        // Fallback to original string if ICU conversion failed
+        if (!U_SUCCESS(status)) {
+          output(i) = input_str;
+        }
       }
     }
   }
diff --git a/tensorflow/core/kernels/string_upper_op.cc b/tensorflow/core/kernels/string_upper_op.cc
index 0a427dcc..5e239a6e 100644
--- a/tensorflow/core/kernels/string_upper_op.cc
+++ b/tensorflow/core/kernels/string_upper_op.cc
@@ -18,7 +18,9 @@ limitations under the License.
 #include <string>
 
 #include "absl/strings/ascii.h"
-#include "unicode/unistr.h"  // from @icu
+#include "unicode/ucnv.h"   // from @icu
+#include "unicode/ustring.h" // from @icu
+#include "unicode/utypes.h"  // from @icu
 #include "tensorflow/core/framework/kernel_def_builder.h"
 #include "tensorflow/core/framework/op_kernel.h"
 #include "tensorflow/core/framework/tensor.h"
@@ -55,9 +57,54 @@ class StringUpperOp : public OpKernel {
     } else {
       // The validation of utf-8 has already been done in GetAttr above.
       for (int64_t i = 0; i < input.size(); ++i) {
-        icu::UnicodeString us(input(i).c_str(), "UTF-8");
-        us.toUpper();
-        us.toUTF8String(output(i));
+        const std::string& input_str = input(i);
+        
+        // Convert UTF-8 to UTF-16
+        UErrorCode status = U_ZERO_ERROR;
+        int32_t utf16_len = 0;
+        u_strFromUTF8(nullptr, 0, &utf16_len, input_str.c_str(), input_str.length(), &status);
+        
+        if (status == U_BUFFER_OVERFLOW_ERROR) {
+          status = U_ZERO_ERROR;
+          std::vector<UChar> utf16_buf(utf16_len);
+          u_strFromUTF8(utf16_buf.data(), utf16_len, nullptr, input_str.c_str(), input_str.length(), &status);
+          
+          if (U_SUCCESS(status)) {
+            // Apply uppercase conversion
+            std::vector<UChar> upper_buf(utf16_len * 2);  // Allow for expansion
+            int32_t upper_len = u_strToUpper(upper_buf.data(), upper_buf.size(), 
+                                           utf16_buf.data(), utf16_len, 
+                                           nullptr, &status);
+            
+            if (U_SUCCESS(status) || status == U_BUFFER_OVERFLOW_ERROR) {
+              if (status == U_BUFFER_OVERFLOW_ERROR) {
+                status = U_ZERO_ERROR;
+                upper_buf.resize(upper_len);
+                upper_len = u_strToUpper(upper_buf.data(), upper_buf.size(),
+                                       utf16_buf.data(), utf16_len,
+                                       nullptr, &status);
+              }
+              
+              if (U_SUCCESS(status)) {
+                // Convert back to UTF-8
+                int32_t utf8_len = 0;
+                u_strToUTF8(nullptr, 0, &utf8_len, upper_buf.data(), upper_len, &status);
+                
+                if (status == U_BUFFER_OVERFLOW_ERROR) {
+                  status = U_ZERO_ERROR;
+                  output(i).resize(utf8_len);
+                  u_strToUTF8(const_cast<char*>(output(i).data()), utf8_len, nullptr,
+                             upper_buf.data(), upper_len, &status);
+                }
+              }
+            }
+          }
+        }
+        
+        // Fallback to original string if ICU conversion failed
+        if (!U_SUCCESS(status)) {
+          output(i) = input_str;
+        }
       }
     }
   }
diff --git a/tensorflow/core/kernels/unicode_ops.cc b/tensorflow/core/kernels/unicode_ops.cc
index e9e0da41..771ed12e 100644
--- a/tensorflow/core/kernels/unicode_ops.cc
+++ b/tensorflow/core/kernels/unicode_ops.cc
@@ -22,13 +22,13 @@ limitations under the License.
 #include <vector>
 
 #include "unsupported/Eigen/CXX11/Tensor"  // from @eigen_archive
-#include "unicode/schriter.h"  // from @icu
 #include "unicode/uchar.h"  // from @icu
 #include "unicode/ucnv.h"  // from @icu
 #include "unicode/ucnv_err.h"  // from @icu
 #include "unicode/umachine.h"  // from @icu
-#include "unicode/uniset.h"  // from @icu
-#include "unicode/unistr.h"  // from @icu
+#include "unicode/ustring.h"  // from @icu
+#include "unicode/utf8.h"  // from @icu
+#include "unicode/utf16.h"  // from @icu
 #include "unicode/uset.h"  // from @icu
 #include "unicode/utf.h"  // from @icu
 #include "unicode/utypes.h"  // from @icu
@@ -51,30 +51,34 @@ limitations under the License.
 namespace tensorflow {
 namespace {
 
-void Encode(const UnicodeEncoding encoding, const icu::UnicodeString& in,
+void Encode(const UnicodeEncoding encoding, const char16_t* in_buf, int32_t in_len,
             tstring* out) {
   if (encoding == UnicodeEncoding::UTF8) {
     out->clear();
-    in.toUTF8String(*out);
+    // Convert UTF-16 to UTF-8
+    UErrorCode status = U_ZERO_ERROR;
+    int32_t dest_len = 0;
+    u_strToUTF8(nullptr, 0, &dest_len, reinterpret_cast<const UChar*>(in_buf), in_len, &status);
+    if (status == U_BUFFER_OVERFLOW_ERROR) {
+      status = U_ZERO_ERROR;
+      out->resize(dest_len);
+      u_strToUTF8(const_cast<char*>(out->data()), dest_len, nullptr, reinterpret_cast<const UChar*>(in_buf), in_len, &status);
+    }
   } else if (encoding == UnicodeEncoding::UTF16BE) {
-    // TODO(gbillock): consider using the
-    // extract(char *dest, int32_t destCapacity, UConverter *cnv)
-    // for UTF16/32
     out->clear();  // subtle: must come before reserve()
-    out->reserve(2 * in.length() + 1);
-    const char16_t* buf = in.getBuffer();
-    for (int i = 0; i < in.length(); ++i) {
+    out->reserve(2 * in_len + 1);
+    for (int i = 0; i < in_len; ++i) {
       // Emit big-endian encoding for UTF-16 always.
-      out->push_back((buf[i] & 0xFF00) >> 8);
-      out->push_back(buf[i] & 0x00FF);
+      out->push_back((in_buf[i] & 0xFF00) >> 8);
+      out->push_back(in_buf[i] & 0x00FF);
     }
   } else if (encoding == UnicodeEncoding::UTF32BE) {
     out->clear();  // subtle: must come before reserve()
-    out->reserve(4 * in.countChar32() + 1);
-    icu::StringCharacterIterator it(in);
-    UChar32 ch;
-    while (it.hasNext()) {
-      ch = it.next32PostInc();
+    out->reserve(4 * in_len + 1);
+    int32_t i = 0;
+    while (i < in_len) {
+      UChar32 ch;
+      U16_NEXT(in_buf, i, in_len, ch);
       out->push_back((ch & 0xFF000000) >> 24);
       out->push_back((ch & 0x00FF0000) >> 16);
       out->push_back((ch & 0x0000FF00) >> 8);
@@ -310,7 +314,7 @@ class UnicodeTranscodeOp : public OpKernel {
   // Consume a codepoint from the input string and add it to the buffer.
   // This function takes care of any replacement configuration on invalid or
   // out-of-range inputs.
-  void TranslateCodepoints(icu::UnicodeString* s, bool* found_any_format_error,
+  void TranslateCodepoints(std::vector<char16_t>* s, bool* found_any_format_error,
                            UChar32 ch, int src_bytes, bool format_error) {
     if (ShouldHandleFormatError(error_options_, ch, format_error)) {
       *found_any_format_error = true;
@@ -320,7 +324,15 @@ class UnicodeTranscodeOp : public OpKernel {
         ch = error_options_.subst;
       }
     }
-    s->append(ch);
+    // Convert UTF-32 code point to UTF-16 and append
+    if (ch <= 0xFFFF) {
+      s->push_back(static_cast<char16_t>(ch));
+    } else {
+      // Convert to surrogate pair
+      UChar32 c = ch - 0x10000;
+      s->push_back(static_cast<char16_t>(0xD800 + ((c >> 10) & 0x3FF)));
+      s->push_back(static_cast<char16_t>(0xDC00 + (c & 0x3FF)));
+    }
   }
 
   // Transcode the string from input encoding to the output_encoding_. If
@@ -328,14 +340,15 @@ class UnicodeTranscodeOp : public OpKernel {
   // config to handle them.
   void Transcode(tstring* s, UConverter* input_encoder,
                  bool* found_any_format_error) {
-    icu::UnicodeString source;
+    std::vector<char16_t> source;
     IterateUnicodeString(
         *s, input_encoder,
         std::bind(&UnicodeTranscodeOp::TranslateCodepoints, this, &source,
                   found_any_format_error, std::placeholders::_1,
                   std::placeholders::_2, std::placeholders::_3));
 
-    Encode(output_encoding_, source, s);
+    Encode(output_encoding_, source.empty() ? nullptr : source.data(), 
+           static_cast<int32_t>(source.size()), s);
   }
 
   string input_encoding_;
@@ -557,7 +570,7 @@ class UnicodeEncodeOp : public OpKernel {
     int idx = 0;
     // Loop through our split dimension to create a new string at each split.
     for (int i = 1; i < input_splits_flat.size(); ++i) {
-      icu::UnicodeString unicode_string;
+      std::vector<char16_t> unicode_buffer;
       OP_REQUIRES(
           context, input_splits_flat(i - 1) <= input_splits_flat(i),
           errors::InvalidArgument(
@@ -575,20 +588,37 @@ class UnicodeEncodeOp : public OpKernel {
                                      code_point <= UCHAR_MAX_VALUE &&
                                      !U_IS_SURROGATE(code_point);
         if (is_scalar_value) {
-          unicode_string.append(code_point);
+          // Convert UTF-32 code point to UTF-16
+          if (code_point <= 0xFFFF) {
+            unicode_buffer.push_back(static_cast<char16_t>(code_point));
+          } else {
+            // Convert to surrogate pair
+            UChar32 c = code_point - 0x10000;
+            unicode_buffer.push_back(static_cast<char16_t>(0xD800 + ((c >> 10) & 0x3FF)));
+            unicode_buffer.push_back(static_cast<char16_t>(0xDC00 + (c & 0x3FF)));
+          }
         } else {
           if (error_options_.error_on_malformatting) {
             context->CtxFailure(errors::InvalidArgument(
                 "Code point is out of range for Unicode, or is a surrogate."));
             return;
           } else if (!error_options_.elide_replacement) {
-            unicode_string.append(error_options_.subst);
+            // Convert replacement character to UTF-16
+            if (error_options_.subst <= 0xFFFF) {
+              unicode_buffer.push_back(static_cast<char16_t>(error_options_.subst));
+            } else {
+              // Convert to surrogate pair
+              UChar32 c = error_options_.subst - 0x10000;
+              unicode_buffer.push_back(static_cast<char16_t>(0xD800 + ((c >> 10) & 0x3FF)));
+              unicode_buffer.push_back(static_cast<char16_t>(0xDC00 + (c & 0x3FF)));
+            }
           }
         }
       }
       // Encode our string and save in the output.
       tstring result;
-      Encode(encoding_, unicode_string, &result);
+      Encode(encoding_, unicode_buffer.empty() ? nullptr : unicode_buffer.data(), 
+             static_cast<int32_t>(unicode_buffer.size()), &result);
       output_tensor_flat(i - 1) = std::move(result);
     }
   }
diff --git a/tensorflow/core/kernels/unicode_script_op.cc b/tensorflow/core/kernels/unicode_script_op.cc
index 70ab6ef3..019a3876 100644
--- a/tensorflow/core/kernels/unicode_script_op.cc
+++ b/tensorflow/core/kernels/unicode_script_op.cc
@@ -13,8 +13,8 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/
 
-#include "unicode/errorcode.h"  // from @icu
 #include "unicode/uscript.h"  // from @icu
+#include "unicode/utypes.h"   // from @icu
 #include "tensorflow/core/framework/op_kernel.h"
 
 namespace tensorflow {
@@ -34,14 +34,14 @@ class UnicodeScriptOp : public OpKernel {
                                             &output_tensor));
     auto output_flat = output_tensor->flat<int32>();
 
-    icu::ErrorCode status;
+    UErrorCode status = U_ZERO_ERROR;
     for (int i = 0; i < input_flat.size(); i++) {
-      UScriptCode script_code = uscript_getScript(input_flat(i), status);
-      if (status.isSuccess()) {
+      UScriptCode script_code = uscript_getScript(input_flat(i), &status);
+      if (U_SUCCESS(status)) {
         output_flat(i) = script_code;
       } else {
         output_flat(i) = -1;
-        status.reset();
+        status = U_ZERO_ERROR;
       }
     }
   }
-- 
2.45.2

